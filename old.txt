
/*
fn build_wasm() {
    Command::new("rustc")
        .args(&[
            "--target", "wasm32-unknown-unknown",
            "-O", 
            "--crate-type=cdylib", 
            "./wasm_modules/src/lib.rs", 
            "-o", "./public/wasm_test.wasm"
        ])
        .status()
        .expect("Failed to compile WebAssembly");
    println!("WebAssembly compiled successfully");
}
*/

/*
fn build_wasm() {
    // Run cargo build in the wasm_modules directory with the correct target
    let status = Command::new("cargo")
        .current_dir("./wasm_modules")
        .args(&[
            "build",
            "--target", "wasm32-unknown-unknown",
            "--release"
        ])
        .status()
        .expect("Failed to compile WebAssembly");
    
    if !status.success() {
        panic!("WebAssembly compilation failed");
    }
    
    // Make sure the public directory exists
    //fs::create_dir_all("./public").expect("Failed to create public directory");
    
    // Copy the compiled wasm file to where the main project expects it
    fs::copy(
        "./wasm_modules/target/wasm32-unknown-unknown/release/wasm_modules.wasm",
        "./public/wasm_test.wasm"
    ).expect("Failed to copy WebAssembly file");
    
    println!("WebAssembly compiled successfully");
}
*/

//wasm-pack build --target no-modules
/*
fn build_wasm(dir: &str) -> Result<(), Box<dyn Error>> {
    println!("Building WASM in {}", dir);
    Command::new("wasm-pack")
        .current_dir(dir)
        //.env("RUSTFLAGS", "--cfg getrandom_backend=\"wasm_js\"")  // Add this line
        .args(&[
            "build",
            "--target",
            "no-modules",
        ])
        .status()
        .expect("Failed to compile WASM.");
    println!("WASM compiled in {}.", dir);
    Ok(())
}
*/
   
    /*

    let builds = vec![
        tokio::spawn(build_wasm("../wasm_decoder")),
        tokio::spawn(build_wasm("../wasm_modules")),
    ];
    
    // Wait for all builds to complete
    for join_handle in join_all(builds).await {
        // Unwrap the JoinHandle result, then propagate any error from the build
        let _ = join_handle?;
    }
    */
    //let wasm64 = encoder::encode_wasm_base64("../public/wasm_test.wasm")?;
    //println!("{:#?}", &text64);
    //println!("{:#?}", &png64);
    //let texture64 = encoder::encode_png_base64(
    //    "../wasm_modules/assets/textures/pyramid.png", 
    //    "bin-png")?;
    
    // model
    //let model64 = encoder::encode_model_base64(
    //    "../public/Fox.glb", "fox")?;

// not needed? --------------------------------------

pub fn encode_text_base64(
    s: &str,
    id: &str
) -> Base {
    let encoded = BASE64_STANDARD.encode(s.as_bytes());
    //println!("text: {}", s);
    //println!("b64:  {}", &encoded);
    Base::new(
        String::from(id),
        encoded
    )
}

pub fn encode_png_base64(
    png_path: &str,
    id: &str,
) -> Result<Base, Box<dyn Error>> {
    let buffer = get_file_bytes(png_path)?;
    let encoded = BASE64_STANDARD.encode(&buffer);
    //println!("png size: {}b", buffer.len());
    //println!("b64:  {}\n size:  {}", &encoded, encoded.len());
    Ok(Base::new(
        String::from(id),
        encoded
    ))
}

pub fn encode_wasm_base64(
    wasm_path: &str, 
    id: &str,
) -> Result<Base, Box<dyn Error>> {
    let buffer = get_file_bytes(wasm_path)?;
    let encoded = BASE64_STANDARD.encode(&buffer);
    Ok(Base::new(
        String::from(id),
        encoded
    ))
}


pub fn encode_wasm_base64_brotli(
    wasm_path: &str, 
    id: &str,
) -> Result<Base, Box<dyn Error>> {
    let buffer = get_file_bytes(wasm_path)?;
    let compressed_buffer = encode_brotli(&buffer)?;
    
    // encode the compressed data as base64
    let encoded = BASE64_STANDARD.encode(&compressed_buffer);
    //let encoded = BASE64_STANDARD.encode(&buffer);
    
    // this might be cooked by we do it again
    //let comp2 = encode_brotli(&encoded.as_bytes().to_vec())?;
    //let encoded2 = BASE64_STANDARD.encode(&comp2);

    Ok(Base::new(
        String::from(id),
        encoded
    ))
}

// is this not the same as everything else?
pub fn encode_model_base64(
    model_path: &str,
    id: &str,
) -> Result<Base, Box<dyn Error>> {
    let buffer = get_file_bytes(model_path)?;
    //let compressed_buffer = encode_brotli(&buffer)?;
    //let encoded = BASE64_STANDARD.encode(&compressed_buffer);
    let encoded = BASE64_STANDARD.encode(&buffer);
    Ok(Base::new(
        String::from(id),
        encoded
    ))
}

/*
pub fn encode_wasm_base94(
    wasm_path: &str,
    id: &str,
) -> Result<Base, Box<dyn Error>> {
    println!("test");
    let mut file = File::open(wasm_path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    println!("test2"); 
    // ncode the compressed data as base94
    let encoded = base94::encode(&buffer, 64);
    println!("test3"); 
    Ok(Base::new(
        String::from(id),
        encoded
    ))
}
*/
    //let wasm_bytes = std::fs::read(wasm_path).unwrap();
    //base64::encode(&wasm_bytes)
    /*
    let mut file = File::open(wasm_path)?;
    let mut buffer = Vec::new();
    file.read_to_end(&mut buffer)?;
    */
pub fn encode_icon_svg_base64(s: String) -> String {
    BASE64_STANDARD.encode(s.as_bytes())
}

/*
    // set our hardcoded conf (later we parse from yaml)
    //let config = set_config_hard().await?;
    //println!("Set config");
// hardcoded config for testing of config logic
// this is so ugly
async fn set_config_hard() -> Result<PackerConfig, Box<dyn Error>> {
    let mut config = PackerConfig::default();
    
    // HTML Metadata
    // should favicon be part of this?
    config.meta = Some(MetaConfig {
        title: Some("htmlpacker".to_string()),
        // we could add a system time with chrono for when it was packed (default)
        description: Some("packed by htmlpacker".to_string()),
        ..Default::default()
    });

    config.favicon = Some(vec![AssetSource::Local(PathBuf::from("../public/icon.svg"))]);

    // let normalize_css = Url::parse("https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css")?;
    // config.styles = Some(vec![AssetSource::Remote(normalize_css)]);
    config.styles = Some(vec![]);

    let mut scripts = Vec::new();
    scripts.push(AssetSource::Local(PathBuf::from("../wasm_decoder/pkg/wasm_decoder.js",)));
    scripts.push(AssetSource::Local(PathBuf::from("../wasm_modules/pkg/wasm_modules.js",)));
    scripts.push(AssetSource::Local(PathBuf::from("../public/decoder.js")));
    scripts.push(AssetSource::Local(PathBuf::from("../public/app2.js")));
    config.scripts = Some(scripts);

    let mut wasm_modules = Vec::new();
    wasm_modules.push(WasmModule {
        id: "bin-wasm-decoder".to_string(),
        source: AssetSource::Local(PathBuf::from("../wasm_decoder/pkg/wasm_decoder_bg.wasm",)),
        compression: CompressionType::None,
    });
    wasm_modules.push(WasmModule {
        id: "bin-wasm".to_string(),
        source: AssetSource::Local(PathBuf::from("../wasm_modules/pkg/wasm_modules_bg.wasm",)),
        compression: CompressionType::Brotli,
    });
    config.wasm = Some(wasm_modules);

    Ok(config)
}
pub async fn pack1() -> Result<(), Box<dyn Error>> {
    // make sure to compile our wasm binaries and js glue first
    wasmbuilder::compile_wasm_modules().await?;
    // there must be a way to refactor this build process.
    // configuration of build file
    //
    // obviously handle the wasm-pack first
    let css_urls = vec![
        //"https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css"
    ];

    // if you want to use javascript libraries,
    // do we need to implement modules tag mode?
    let external_scripts_list = vec![
        //"https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js",
        //"https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/TrackballControls.min.js"
    ];

    let local_scripts_list = vec![
        "../wasm_decoder/pkg/wasm_decoder.js",
        "../wasm_modules/pkg/wasm_modules.js", // bindgen
        "../public/decoder.js", // decode wasm from base64
        "../public/app2.js", // app logic
        //"../public/app.js", // app logic
        //"../public/script.js", // test script
    ];

    // external css
    let css_text = htmlpacker::get_css_string(css_urls).await?;

    // favicon processing
    //let icon_path = "../public/icon.svg";
    //let icon_svg = htmlpacker::get_local_script(Path::new(icon_path)).unwrap();
    //let icon_svg64 = encoder::encode_icon_svg_base64(icon_svg);
    let icon_svg64 = encoder::encode_base64("../public/icon.svg", "").unwrap();

    //println!("{:?}", icon_svg64);
    let icons = vec![icon_svg64.text];

    // external scripts to fetch
    let external_scripts_text = htmlpacker::get_external_scripts_text(
        external_scripts_list).await?;

    // get local scripts
    let mut local_scripts_text = htmlpacker::get_local_scripts_text(
        local_scripts_list)?;
    //println!("{:?}", external_scripts_text);
    //println!("{:?}", local_scripts_text);

    // rename wasm_bindgen so that we don't have double definition conflicts
    local_scripts_text[0] = local_scripts_text[0].replace(
        "wasm_bindgen",
        "wasm_decoder");

    // base64 encoder
    // encode_base64 is all you need now
    //let text64 = encoder::encode_text_base64("hello world!!!\nt. packer", "bin-text");
    //let png64 = encoder::encode_png_base64("../public/wizard.png", "bin-png")?;
    //let wasm64 = encoder::encode_wasm_base94("../wasm_modules/pkg/wasm_modules_bg.wasm", "bin-wasm")?;
    // this decoder is the reason we can do brotli decompress
    let wasm_decoder64 = encoder::encode_base64(
        "../wasm_decoder/pkg/wasm_decoder_bg.wasm", 
        "bin-wasm-decoder")?;
    let wasm_module64 = encoder::encode_brotli_base64(
        "../wasm_modules/pkg/wasm_modules_bg.wasm", 
        "bin-wasm")?;
    
    let bin: Vec<encoder::Base> = vec![
        //text64,
        //png64,
        wasm_decoder64,
        wasm_module64,
        //texture64,
        //model64,
    ];

    let markup = htmlpacker::page(
        css_text,
        icons,
        external_scripts_text,
        local_scripts_text,
        bin,
    );

    let html = markup.into_string();
    //println!("{}", html);
    htmlpacker::save_html(html)?;

    Ok(())
}
*/
/*
#[derive(Debug, Serialize, Deserialize)]
struct YamlAssets {
    local: Option<YamlAssetList>,
    remote: Option<YamlAssetList>,
}

#[derive(Debug, Serialize, Deserialize)]
#[serde(untagged)]
enum YamlAssetList {
    Single(String),
    Multiple(Vec<String>),
}
*/
